// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// --------------------
// Enums
// --------------------
enum ExperienceType {
  BIKE_TOUR
  KAYAK_TOUR
  WALKING_TOUR
  MINI_CRUISE
}

// Idiomas base garantizados como idioma principal del tour (el cliente elige 1)
enum LanguageBase {
  CA
  ES
  EN
}

// Idiomas ampliados (para guías y para browserLanguage detectado)
enum LanguageCode {
  CA
  ES
  EN
  DE
  FR
  IT
}

enum UserRole {
  ADMIN
  GUIDE
  STAFF
}

enum ReservationStatus {
  HOLD       // plaza retenida mientras paga (con expiración)
  CONFIRMED  // pago OK, plaza confirmada
  WAITING    // lista de espera (sin plaza)
  CANCELLED  // cancelada
  EXPIRED    // expiró (hold vencido / pasó cierre / waitlist expirada)
}

enum PaymentStatus {
  NOT_REQUIRED
  REQUIRES_PAYMENT
  PENDING
  SUCCEEDED
  FAILED
  CANCELED
  REFUNDED
}

enum CancelReason {
  CUSTOMER
  OPERATOR
  WEATHER
}

enum ReservationCreatedEmailKind {
  HOLD
  WAITING
}

// --------------------
// Users (empleados)
// --------------------
model User {
  id       String   @id @default(cuid())
  email    String   @unique
  name     String?
  role     UserRole @default(STAFF)
  isActive Boolean  @default(true)

  // Para guías: idiomas que domina
  languages LanguageCode[] @default([])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Reservas asignadas a este guía
  assignedReservations Reservation[] @relation("GuideAssignments")

  @@index([role, isActive])
}

// --------------------
// Customers (clientes sin cuenta)
// --------------------
model Customer {
  id        String   @id @default(cuid())
  // En tu nuevo flujo, en la 1ª ventana solo pides email.
  // El nombre/apellidos se completan en la 3ª ventana -> lo hacemos opcional.
  name      String?
  email     String   @unique
  phone     String?
  createdAt DateTime @default(now())

  reservations Reservation[]

  @@index([email])
}

// --------------------
// Experiences (ficha pública)
// --------------------
model Experience {
  id          String         @id @default(cuid())
  slug        String         @unique
  title       String
  description String
  type        ExperienceType

  durationMin Int
  difficulty  String?
  coverImage  String?
  location    String?
  isPublished Boolean @default(false)

  // Marketing / info (no garantiza disponibilidad real, pero útil para mostrar)
  supportedLanguages LanguageCode[] @default([])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  sessions Session[]
}

// --------------------
// Sessions (salidas/turnos)
// --------------------
model Session {
  id           String   @id @default(cuid())
  experienceId String
  startAt      DateTime
  endAt        DateTime?
  meetingPoint String
  mapsUrl      String?

  // Capacidad
  maxSeatsTotal Int
  maxPerGuide   Int

  // Cierre de reservas: startAt - 4h
  bookingClosesAt DateTime

  // Precio (Stripe)
  priceCents      Int
  currency        String  @default("eur")
  requiresPayment Boolean @default(true)

  // Política de reembolso (por sesión) - por defecto 48h/24h/50%
  refundFullBeforeHours    Int @default(48) // >= 48h => 100%
  refundPartialBeforeHours Int @default(24) // >= 24h y < 48h => parcial
  refundPartialPercent     Int @default(50) // parcial => 50%

  isCancelled Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  experience   Experience    @relation(fields: [experienceId], references: [id], onDelete: Cascade)
  reservations Reservation[]

  @@index([experienceId, startAt])
  @@index([startAt, bookingClosesAt])
}

// --------------------
// Reservations
// --------------------
model Reservation {
  id         String @id @default(cuid())
  sessionId  String
  customerId String

  // Asignación a guía (User role=GUIDE)
  guideUserId String?

  status        ReservationStatus @default(HOLD)
  holdExpiresAt DateTime? // si status=HOLD, caduca (ej. now + 15/30 min)

  // Pax (nuevo flujo: se pregunta en la 1ª ventana)
  // Reglas en app: adultsCount >= 1, minorsCount >= 0, totalPax = adultsCount + minorsCount
  adultsCount Int @default(1)
  minorsCount Int @default(0)
  totalPax    Int @default(1)

  // Idioma del tour:
  // - en WAITING aún no lo eligen => opcional
  // - en HOLD/CONFIRMED debería existir (lo validas en backend antes de Stripe/confirmación)
  tourLanguage LanguageBase?

  // Interno: idioma detectado del navegador
  browserLanguage LanguageCode?

  // Cancelación y métricas
  cancelledAt       DateTime?
  cancelReason      CancelReason?
  refundAmountCents Int @default(0)

  // Emails (idempotencia / anti-duplicados)
  // 1) Email al crear HOLD o WAITING
  createdEmailSentAt DateTime?
  createdEmailKind   ReservationCreatedEmailKind?

  // 2) Email al confirmar pago
  confirmedEmailSentAt DateTime?

  // 3) Email "ya hay sitio" (para WAITING -> avisar cuando freeSeats >= totalPax)
  availabilityEmailSentAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  session   Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  customer  Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  guideUser User?    @relation("GuideAssignments", fields: [guideUserId], references: [id], onDelete: SetNull)

  payment Payment?

  // Evita doble reserva del mismo cliente en la misma sesión
  @@unique([sessionId, customerId])

  // Índices útiles
  @@index([sessionId, status])
  @@index([sessionId, status, holdExpiresAt])
  @@index([status, holdExpiresAt])
  @@index([status, availabilityEmailSentAt])
  @@index([cancelReason, cancelledAt])
  @@index([guideUserId, status])
}

// --------------------
// Payments (Stripe)
// --------------------
model Payment {
  id            String @id @default(cuid())
  reservationId String @unique

  status      PaymentStatus @default(REQUIRES_PAYMENT)
  amountCents Int
  currency    String        @default("eur")

  // Stripe refs (Checkout recomendado para MVP)
  stripeCheckoutSessionId String? @unique
  stripePaymentIntentId   String? @unique

  // Refund tracking
  stripeRefundId      String? @unique
  refundedAmountCents Int     @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  reservation Reservation @relation(fields: [reservationId], references: [id], onDelete: Cascade)

  @@index([status])
}
